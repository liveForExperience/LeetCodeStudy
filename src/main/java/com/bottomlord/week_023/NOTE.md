# LeetCode_991_坏了的计算器
## 题目
在显示着数字的坏计算器上，我们可以执行以下两种操作：
```
双倍（Double）：将显示屏上的数字乘 2；
递减（Decrement）：将显示屏上的数字减 1 。
最初，计算器显示数字 X。
```
返回显示数字 Y 所需的最小操作数。

示例 1：
```
输入：X = 2, Y = 3
输出：2
解释：先进行双倍运算，然后再进行递减运算 {2 -> 4 -> 3}.
```
示例 2：
```
输入：X = 5, Y = 8
输出：2
解释：先递减，再双倍 {5 -> 4 -> 8}.
```
示例 3：
```
输入：X = 3, Y = 10
输出：3
解释：先双倍，然后递减，再双倍 {3 -> 6 -> 5 -> 10}.
```
示例 4：
```
输入：X = 1024, Y = 1
输出：1023
解释：执行递减运算 1023 次
```
提示：
```
1 <= X <= 10^9
1 <= Y <= 10^9
```
## 解法
### 思路
贪心算法：
- `Y > X`时，循环执行如下操作，并记录执行次数`count`：
    - 偶数：除2
    - 奇数：加1
- `Y <= X`时：`count + Y - X`，如果处理过后，Y少于X了，那么就计算相差的值，通过相加来补充
### 代码
```java
class Solution {
    public int brokenCalc(int X, int Y) {
        int count = 0;
        while (X < Y) {
            count++;
            if (Y % 2 == 1) {
                Y++;
            } else {
                Y /= 2;
            }
        }
        
        return count + X - Y;
    }
}
```
# LeetCode_153_寻找旋转排序数组中的最小值
## 题目
假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

请找出其中最小的元素。

你可以假设数组中不存在重复元素。

示例 1:
```
输入: [3,4,5,1,2]
输出: 1
```
示例 2:
```
输入: [4,5,6,7,0,1,2]
输出: 0
```
## 解法
### 思路
- 暂存数组第一个值作为最小值
- 从第二个元素开始遍历数组
- 与上次循环暂存的值进行比较，因为是升序，如果小于上一个值，就直接返回当前值
- 暂存当前值，作为下一个循环的前值
- 如果没有，就返回第一个值
### 代码
```java
class Solution {
    public int findMin(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int first = nums[0], pre = first;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] < pre) {
                return nums[i];
            }
            
            pre = nums[i];
        }
        
        return first;
    }
}
```