# [LeetCode_335_路径交叉](https://leetcode-cn.com/problems/self-crossing/)
## 题目
给定一个含有 n 个正数的数组 x。从点 (0,0) 开始，先向北移动 x[0] 米，然后向西移动 x[1] 米，向南移动 x[2] 米，向东移动 x[3] 米，持续移动。也就是说，每次移动后你的方位会发生逆时针变化。

编写一个 O(1) 空间复杂度的一趟扫描算法，判断你所经过的路径是否相交。

示例 1:
```
┌───┐
│   │
└───┼──>
    │

输入: [2,1,1,2]
输出: true 
```
示例 2:
```
┌──────┐
│      │
│
│
└────────────>

输入: [1,2,3,4]
输出: false 
```
示例 3:
```
┌───┐
│   │
└───┼>

输入: [1,1,1,1]
输出: true 
```
## 解法
### 思路
会相交的情况：
- 假设最后一条边是i，边的长度是`[i]`
- 移动次数大于3
- 移动4次相交的条件：
    - `[i - 2] <= [i]`
    - `[i - 1] <= [i - 3]`
- 移动5次相交的条件：
    - 如果最后4次的状态和移动四次的状态相同，那么就会相交
    - 如果`[i - 1] == [i - 3]`，且`[i - 2] <= [i - 4]`
- 移动6次及以上相交的条件：
    - 最后4次的状态和移动4次相交的状态相同
    - `[i - 2]`比`[i - 4]`长，且`[i - 1]` + `[i - 5]`比`[i - 3]`长，导致如果相交，就是和`i - 5`相交，这种情况的条件就是：
        - `[i - 1]` + `[i - 5]` >= `[i - 3]`
        - `[i - 2]` + `[i]` >= `[i - 4]`
        - `[i - 4]` > `[i - 2]`
        - `[i - 3]` > `[i - 1]`
#### 代码
```java
class Solution {
    public boolean isSelfCrossing(int[] x) {
        if (x.length <= 3) {
            return false;
        }

        for (int i = 3; i < x.length; i++) {
            if (x[i] >= x[i - 2] && x[i - 1] <= x[i - 3]) {
                return true;
            }

            if (i >= 4 && x[i - 1] == x[i - 3] && x[i] + x[i - 4] >= x[i - 2]) {
                return true;
            }

            if (i >= 5 && x[i] + x[i - 4] >= x[i - 2] && x[i - 5] + x[i - 1] >= x[i - 3] && x[i - 4] < x[i - 2] && x[i] < x[3]) {
                return true;
            }
        }

        return false;
    }
}
```