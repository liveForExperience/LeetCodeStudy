# Contest_1_交换字符使得字符串相同
## 题目
有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 "x" 和 "y"，你需要通过「交换字符」的方式使这两个字符串相同。

每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。

交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。

最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。

示例 1：
```
输入：s1 = "xx", s2 = "yy"
输出：1
解释：
交换 s1[0] 和 s2[1]，得到 s1 = "yx"，s2 = "yx"。
```
示例 2：
```
输入：s1 = "xy", s2 = "yx"
输出：2
解释：
交换 s1[0] 和 s2[0]，得到 s1 = "yy"，s2 = "xx" 。
交换 s1[0] 和 s2[1]，得到 s1 = "xy"，s2 = "xy" 。
注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 "yx"，因为我们只能交换属于两个不同字符串的字符。
```
示例 3：
```
输入：s1 = "xx", s2 = "xy"
输出：-1
```
示例 4：
```
输入：s1 = "xxyyxyxyxx", s2 = "xyyxyxxxyx"
输出：4
```
提示：
```
1 <= s1.length, s2.length <= 1000
s1, s2 只包含 'x' 或 'y'。
```
## 解法
### 思路
- 计算两个字符串中一组下标对应的字符不同的个数
- 如果对数为奇数则无法通过交换获得相等字符串
- 通过观察可得：
    1. 两个字符串的字符呈现`xx`和`yy`这种情况，那么交换次数为1
    2. 如果呈现`xy`和`yx`，交换的次数为2
- 所以可以通过计算一个字符串x和y的个数
    1. 通过计算`x / 2`和`y / 2`，获得如上情况1的个数
    2. 通过计算`x % 2`或`y % 2`，获得如上情况2的个数，其实这种情况就是要么x和y的个数是奇数的情况，就+2，否则就不加
### 代码
```java

```
# Contest_2_统计优美子数组
## 题目
给你一个整数数组 nums 和一个整数 k。

如果某个子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。

请返回这个数组中「优美子数组」的数目。

示例 1：
```
输入：nums = [1,1,2,1,1], k = 3
输出：2
解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。
```
示例 2：
```
输入：nums = [2,4,6], k = 1
输出：0
解释：数列中不包含任何奇数，所以不存在优美子数组。
```
示例 3：
```
输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2
输出：16
```
提示：
```
1 <= nums.length <= 50000
1 <= nums[i] <= 10^5
1 <= k <= nums.length
```
## 解法
### 思路

### 代码
```java

```
# Contest_3_移除无效的括号
## 题目
给你一个由 '('、')' 和小写字母组成的字符串 s。

你需要从字符串中删除最少数目的 '(' 或者 ')' （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。

请返回任意一个合法字符串。

有效「括号字符串」应当符合以下 任意一条 要求：
```
空字符串或只包含小写字母的字符串
可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」
可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」
```
示例 1：
```
输入：s = "lee(t(c)o)de)"
输出："lee(t(c)o)de"
解释："lee(t(co)de)" , "lee(t(c)ode)" 也是一个可行答案。
```
示例 2：
```
输入：s = "a)b(c)d"
输出："ab(c)d"
```
示例 3：
```
输入：s = "))(("
输出：""
解释：空字符串也是有效的
```
示例 4：
```
输入：s = "(a(b(c)d)"
输出："a(b(c)d)"
```
提示：
```
1 <= s.length <= 10^5
s[i] 可能是 '('、')' 或英文小写字母
```
## 解法
### 思路
- 计算应该存在的左右括号的个数
    - 遍历字符串，遇到多少左括号就记录几个`left` 
    - 遇到右括号的时候，判断左括号个数是否大于右括号个数
        - 如果不是说明这个右括号是不平衡的，不计数
        - 如果是小于左括号个数的，计数`right`
    - 然后`left`再根据左右括号的最小值重新赋值，避免左括号多的情况
- 声明一个StringBuilder
- 遍历字符串生成平衡的字符串
    - 如果不是括号就append
    - 如果是左括号，且`left > 0`，就append
    - 如果是右括号，且`right > 0`，且`left < right`(说明已经append的左括号多余右括号)，就append
    - 其他的情况就跳过
- 最后返回新生成的字符串
### 代码
```java
class Solution {
    public String minRemoveToMakeValid(String s) {
        int left = 0, right = 0;
        for (char c : s.toCharArray()) {
            if (c == '(') {
                left++;
            }
            
            if (c == ')') {
                if (left > right) {
                    right++;
                }
            }
        }
        
        left = Math.min(left, right);
        
        StringBuilder sb = new StringBuilder();
        for (char c : s.toCharArray()) {
            if (c == '(') {
                if (left > 0) {
                    left--;
                    sb.append(c);
                }
            } else if (c == ')') {
                if (right > 0 && left < right) {
                    right--;
                    sb.append(c);
                }
            } else {
                sb.append(c);
            }
        }

        return sb.toString();
    }
}
```
# Contest_4_检查好数组
## 题目
给你一个正整数数组 nums，你需要从中任选一些子集，然后将子集中每一个数乘以一个 任意整数，并求出他们的和。

假如该和结果为 1，那么原数组就是一个「好数组」，则返回 True；否则请返回 False。

示例 1：
```
输入：nums = [12,5,7,23]
输出：true
解释：挑选数字 5 和 7。
5*3 + 7*(-2) = 1
```
示例 2：
```
输入：nums = [29,6,10]
输出：true
解释：挑选数字 29, 6 和 10。
29*1 + 6*(-3) + 10*(-1) = 1
```
示例 3：
```
输入：nums = [3,6]
输出：false
```
提示：
```
1 <= nums.length <= 10^5
1 <= nums[i] <= 10^9
```
## 解法
### 思路

### 代码
```java

```